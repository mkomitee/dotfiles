#!/usr/bin/env python
'''Simple script to create a new python project

$ new-python-project project-name

Will create a project skeleton:
    project-name/.gitignore
    project-name/setup.py
    project-name/REQUIREMENTS
    project-name/project-name
    project-name/project-name/__init__.py
    project-name/tests
    project-name/tests/__init__.py

If there exists an environment variable $VENV_ROOT, will create a python
virtual environment named project-name within that directory and activate it.
If no $VENV_ROOT exists, it will create the virtual environment in
$HOME/.virtualenvs/.

The metadata encoded in the projects setup.py (and main __init__.py) will be
pulled out of your git config if you have one.

Will also setup a git repository.
'''

###############################################################################

import argparse
import sys
import os
import logging
import subprocess
import datetime

__description__ = 'Simple script to create a new python project'
__version__ = '1.0'


class FailureException(Exception):
    '''Indicates an unrecoverable failure'''
    pass


def camelize(value):
    '''Converts an underscore_string to a camelcaseString'''
    def camelcase():
        '''Helper which yields appropriate functions for camelizing'''
        yield str.lower
        while True:
            yield str.capitalize
    c_func = camelcase()
    return "".join(c_func.next()(x) if x else '_' for x in value.split('_'))


def parse_arguments():
    '''parse commandline arguments'''
    parser = argparse.ArgumentParser(description=__description__)
    parser.add_argument('project', help='project name')
    parser.add_argument('--vroot', metavar='ROOT', help='virtualenv root')
    parser.add_argument('--python', metavar='BINARY',
                        help='virtualenv python interpreter')
    parser.add_argument('--debug', action='store_true', help='debug',
                        default=False)
    options = parser.parse_args()
    if options.vroot is None:
        if 'VENV_ROOT' in os.environ:
            options.vroot = os.environ['VENV_ROOT']
        else:
            options.vroot = os.path.join(os.environ['HOME'], '.virtualenvs')
    return options


def git_config(key):
    '''queries git config for information'''
    if not find_binary('git'):
        return None

    command = ['git', 'config', key]

    logging.debug("executing {0!r}".format(command))
    try:
        proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, stderr = proc.communicate()
    except OSError:
        return None
    for line in stdout.rstrip().split("\n"):
        logging.debug("git config stdout: %s", line)
    for line in stderr.rstrip().split("\n"):
        logging.debug("git config stderr: %s", line)
    if proc.returncode != 0:
        return None
    return stdout.strip()


def generate_skeleton(project):
    '''generates a skeleton python project'''
    if os.path.exists(project):
        raise FailureException("{0} already exists".format(project))

    # Make directory structure
    os.makedirs(os.path.join(project, project))
    os.makedirs(os.path.join(project, 'tests'))
    os.makedirs(os.path.join(project, 'doc'))

    # Create ignore file
    with open(os.path.join(project, '.gitignore'), 'w') as fhandle:
        fhandle.write('*.pyc\n*.pyo')

    # Create requirements file
    requirements = ['nose', 'pylint', 'pep8']
    with open(os.path.join(project, 'REQUIREMENTS'), 'w') as fhandle:
        fhandle.write("\n".join(requirements))

    with open(os.path.join(project, 'tests', '__init__.py'), 'w') as fhandle:
        pass

    with open(os.path.join(project, 'README'), 'w') as fhandle:
        fhandle.write('''Please type a descriptive readme''')

    # Determine editor
    if 'EDITOR' in os.environ:
        editor = os.environ['EDITOR']
    elif 'VISUAL' in os.environ:
        editor = os.environ['VISUAL']
    else:
        editor = 'vi'

    # Build project init file
    email = git_config('user.email')
    author = git_config('user.name')
    if email is None:
        email = 'REPLACE WITH YOUR EMAIL'
    if author is None:
        author = 'REPLACE WITH YOUR NAME'
    with open(os.path.join(project, project, '__init__.py'), 'w') as fhandle:
        fhandle.write('''\'\'\'short one line description\'\'\'

__author__ = '{1}'      # you
__email__ = '{3}'       # your email address
__keywords__ = ['{0}']  # keywords to help find this library
__license__ = 'BSD'     # check http://pypi.python.org/pypi?%3Aaction=list_classifiers
                        # for valid licenses
__status__ = 'Planning' # Planning, Pre-Alpha, Alpha, Beta, Production/Stable, Mature, & Inactive
                        # are all valid statuses
__url__ = ''            # modules website
__packages__ = ['{0}']
__version__ = '1.0.0'
'''.format(project, author, datetime.datetime.now().year, email))

    # Build test init file
    with open(os.path.join(project, 'tests', '{0}_tests.py'.format(project)),
              'w') as fhandle:
        fhandle.write('''#!/usr/bin/env python
\'\'\'test {0} module \'\'\'

from nose.tools import *
import {0}

def setup():
    pass

def teardown():
    pass

def test_example():
    assert_true(True)
'''.format(project))

    # # Build setup.py
    with open(os.path.join(project, 'setup.py'), 'w') as fhandle:
        fhandle.write('''#!/usr/bin/env python
try:
    from setuptools import setup
except ImportError:
    from distutils.core import setup

import os

import {0}

_status_map = {{
    'Planning':          'Development Status :: 1 - Planning',
    'Pre-Alpha':         'Development Status :: 2 - Pre-Alpha',
    'Alpha':             'Development Status :: 3 - Alpha',
    'Beta':              'Development Status :: 4 - Beta',
    'Production/Stable': 'Development Status :: 5 - Production/Stable',
    'Mature':            'Development Status :: 6 - Mature',
    'Inactive':          'Development Status :: 7 - Inactive'
}}

_license_map = {{
    'AFL':               'License :: OSI Approved :: Academic Free License (AFL)',
    'Apache':            'License :: OSI Approved :: Apache Software License',
    'BSD':               'License :: OSI Approved :: BSD License',
    'Common Public':     'License :: OSI Approved :: Common Public License',
    'EUPL':              'License :: OSI Approved :: European Union Public Licence 1.0 (EUPL 1.0)',
    'EUPL 1.1':          'License :: OSI Approved :: European Union Public Licence 1.1 (EUPL 1.1)',
    'FDL':               'License :: OSI Approved :: GNU Free Documentation License (FDL)',
    'GPL':               'License :: OSI Approved :: GNU General Public License (GPL)',
    'LGPL':              'License :: OSI Approved :: GNU Library or Lesser General Public License (LGPL)',
    'ISC':               'License :: OSI Approved :: ISC License (ISCL)',
    'MIT':               'License :: OSI Approved :: MIT License',
    'MPL':               'License :: OSI Approved :: Mozilla Public License 1.0 (MPL)',
    'MPL 1.1':           'License :: OSI Approved :: Mozilla Public License 1.1 (MPL 1.1)',
    'MPL 2.0':           'License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)',
    'Python':            'License :: OSI Approved :: Python Software Foundation License',
    'W3C':               'License :: OSI Approved :: W3C License',
    'Other/Proprietary': 'License :: Other/Proprietary License',
    'Public Domain':     'License :: Public Domain',
}}

# Utility function to read the README & REQUIREMENTS files.
def read(fname):
    return open(os.path.join(os.path.dirname(__file__), fname)).read().strip()

config = {{
    'name': {0}.__name__,
    'version': {0}.__version__,
    'author': {0}.__author__,
    'author_email': {0}.__email__,
    'description': {0}.__doc__,
    'license': {0}.__license__,
    'keywords': {0}.__keywords__,
    'url': {0}.__url__,
    'packages': {0}.__packages__,
    'long_description': read('README'),
    'install_requires': read('REQUIREMENTS').split("\\n"),
    'scripts': [],

    # Please see http://pypi.python.org/pypi?%3Aaction=list_classifiers
    # for additional classifiers like topic and intended audience
    'classifiers': [
        _status_map[{0}.__status__],
        _license_map[{0}.__license__],
        'Programming Language :: Python',
    ]
}}

setup(**config)
'''.format(project))

    return ['pip install --quiet -r REQUIREMENTS', 'rehash',
            '{0} {1}/__init__.py setup.py README'.format(editor, project)]


def find_binary(binary):
    '''returns true/false if a binary is available in the path'''
    for part in os.environ['PATH'].split(':'):
        logging.debug("checking %s for %s", part, binary)
        if os.access(os.path.join(part, binary), os.X_OK):
            logging.debug("found %s in %s", binary, part)
            return True
    return False


def create_virtualenv(project, root, python):
    '''creates a virtual environment for a project'''
    virtualenv = os.path.join(root, project)

    # Ensure the virtualenv doesnt already exist
    if os.path.exists(virtualenv):
        raise FailureException("virtualenv {0} already exists".format(project))

    # Make sure that there's a place to put the virtualenv
    try:
        logging.debug("creating %s", root)
        os.makedirs(root)
    except OSError as exc:
        if exc.errno != 17:
            raise FailureException("cannot make virtualenv {0}: {1}".format(
                project,
                exc.strerror))

    # Verify virtualenv is in our path
    if not find_binary('virtualenv'):
        raise FailureException("executable virtualenv not in current path")

    # Generate virtualenv command
    command = ['virtualenv']
    if python:
        command += ['-p', python]
        if not os.access(python, os.X_OK):
            raise FailureException("{0} is not executable".format(python))
    command.append(virtualenv)

    # Run virtualenv
    logging.debug("executing {0!r}".format(command))
    try:
        proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                                stderr=subprocess.PIPE)
        stdout, stderr = proc.communicate()
    except OSError as exc:
        raise FailureException("failure running virtualenv: {0}".format(
            exc.strerror))
    for line in stdout.rstrip().split("\n"):
        logging.debug("virtualenv stdout: %s", line)
    for line in stderr.rstrip().split("\n"):
        logging.debug("virtualenv stderr: %s", line)
    if proc.returncode != 0:
        raise FailureException("virtualenv exited {0}".format(proc.returncode))

    activate = os.path.join(virtualenv, 'bin', 'activate')
    if 'SHELL' in os.environ:
        shell = os.path.basename(os.environ['SHELL'])
        if shell.endswith('csh'):
            activate = os.path.join(virtualenv, 'bin', 'activate.csh')
        elif shell == 'fish':
            activate = os.path.join(virtualenv, 'bin', 'activate.fish')
    commands = ['source {0}'.format(activate)]

    packages = ['ipython']
    if sys.version_info.major < 3 and sys.version_info.minor < 7:
        packages.append("unittest2")

    for package in packages:
        commands.append('pip install --quiet {0}'.format(package))

    return commands


def setup_repository(project):
    '''creates a git repository in the given directory'''
    if not find_binary('git'):
        return False

    for command in [
        ['git', 'init'],
        ['git', 'add', '-A'],
        ['git', 'commit', '-m"import"']]:
        try:
            proc = subprocess.Popen(command, stdout=subprocess.PIPE,
                                    stderr=subprocess.PIPE, cwd=project)
            stdout, stderr = proc.communicate()
        except OSError:
            return False
        for line in stdout.rstrip().split("\n"):
            logging.debug("%s stdout: %s", ' '.join(command), line)
        for line in stderr.rstrip().split("\n"):
            logging.debug("%s stderr: %s", ' '.join(command), line)
        if proc.returncode != 0:
            return False

    return True


def main():
    '''main program logic'''
    options = parse_arguments()
    if options.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.debug("args: %r", options)
    try:
        skel = generate_skeleton(options.project)
        activate = create_virtualenv(options.project, options.vroot,
                                     options.python)
        setup_repository(options.project)
    except FailureException as exc:
        print >> sys.stderr, exc
        return 1
    else:
        print "To start working on your project run the following:"
        print "cd {0}".format(options.project)
        for cmd in activate:
            print cmd
        for cmd in skel:
            print cmd
        return 0

if __name__ == '__main__':
    FORMAT = '%(asctime)-15s %(levelname)s %(funcName)s:%(lineno)d %(message)s'
    logging.basicConfig(format=FORMAT)
    sys.exit(main())
