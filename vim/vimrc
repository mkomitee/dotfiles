" Preamble ----------------------------------------------------------------- {{{
set nocompatible
set rtp+=~/.vim/bundle/vundle
call vundle#rc()
filetype plugin indent on
syntax enable

silent execute '!mkdir -p $HOME/.vimdata/vimbackup'
silent execute '!mkdir -p $HOME/.vimdata/vimswap'
silent execute '!mkdir -p $HOME/.vimdata/vimviews'
silent execute '!mkdir -p $HOME/.vimdata/vimundo'
silent execute '!mkdir -p $HOME/.vimdata/fufdata'
silent execute '!mkdir -p $HOME/.vimdata/ctrlp'

for file in split(glob("$HOME/.vim/functions/*.vim"))
    exe "source " . file
endfor

" }}}
" Install Plugins ---------------------------------------------------------- {{{
Bundle 'vundle'
" Plugins, ...
Bundle 'Lokaltog/vim-easymotion'
Bundle 'Lokaltog/vim-powerline'
Bundle 'Rainbow-Parenthsis-Bundle'
Bundle 'ShowMarks'
Bundle 'The-NERD-Commenter'
Bundle 'YankRing.vim'
Bundle 'ack.vim'
Bundle 'ervandew/screen'
Bundle 'ervandew/supertab'
Bundle 'fugitive.vim'
Bundle 'garbas/vim-snipmate'
Bundle 'godlygeek/tabular'
Bundle 'honza/snipmate-snippets'
Bundle 'kien/ctrlp.vim'
Bundle 'majutsushi/tagbar'
Bundle 'michaeljsmith/vim-indent-object'
Bundle 'repeat.vim'
Bundle 'scrooloose/nerdtree'
Bundle 'simplenote.vim'
Bundle 'surround.vim'
Bundle 'tmatilai/gitolite.vim'
Bundle 'vim-indent-object'
" Filetype Plugins
Bundle 'ajf/puppet-vim'
Bundle 'endwise.vim'
Bundle 'pep8'
Bundle 'python_match.vim'
Bundle 'pythoncomplete'
Bundle 'ruby-matchit'
Bundle 'textobj-rubyblock'
" Colors
Bundle 'altercation/vim-colors-solarized'
Bundle 'gmarik/ingretu'
Bundle 'mkomitee/Color-Sampler-Pack'
Bundle 'mkomitee/Vim-Tomorrow-Theme'
Bundle 'wgibbs/vim-irblack'
" Dependencies, ...
Bundle 'MarcWeber/vim-addon-mw-utils'
Bundle 'textobj-user'
Bundle 'tomtom/tlib_vim'

" }}}
" Preferences -------------------------------------------------------------- {{{
set encoding=utf-8
set fileformats=unix,mac,dos
set autoindent
set showmode
set showcmd
set hidden
set visualbell t_vb=  " No bells; No flashing!
set ttyfast
set backspace=indent,eol,start
set number
set laststatus=2
set history=10000
if exists('&undofile')
    set undofile
    set undoreload=10000
endif
set undolevels=10000
set list
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮,trail:♦
set lazyredraw
set matchtime=3
set showbreak=↪
set splitbelow
set splitright
set fillchars=diff:⣿
set ttimeout
set notimeout
set nottimeout
set autowrite
set shiftround
set autoread
set title
set dictionary=$HOME/.vimdata/words
set showfulltag
set shortmess+=filmnrxoOtTI
set iskeyword-=:
set iskeyword-=;
set iskeyword-=,
set iskeyword+=_
set display+=lastline
set diffopt=filler,iwhite
set updatecount=10
set completeopt=longest,menu,menuone
set switchbuf=usetab
set nostartofline
set viminfo='100,<50,s10,h,n~/.vimdata/viminfo
set preserveindent
set pumheight=10
set report=0
set switchbuf=useopen,usetab
if has('unnamedplus')
    set clipboard=unnamed,unnamedplus,autoselect
else
    set clipboard=unnamed,autoselect
endif

if has('mouse')
    set mouse=a
endif

" }}}
" Searching & Movement ----------------------------------------------------- {{{
set incsearch
set ignorecase
set smartcase
set hlsearch
set gdefault
set showmatch
set matchpairs+=<:>
set magic

noremap <leader><space> :nohl<cr>:call clearmatches()<cr>

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>/ :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>

set scrolloff=5
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

" Keep search matches in the middle of the window and pulse the line when moving
" to them.
nnoremap n nzzzv:call PulseCursorLine()<cr>
nnoremap N Nzzzv:call PulseCursorLine()<cr>
nnoremap g; g;zzzv:call PulseCursorLine()<cr>
nnoremap g, g,zzzv:call PulseCursorLine()<cr>

" j and k will go one line, even if they're wrapped
nnoremap j gj
nnoremap k gk

" start / end of line should be easier to reach than ^ and $
nnoremap H ^
nnoremap L g_

" when using marks, all by default mark columns as well
nnoremap ' `

" }}}
" Disable annoying maps ---------------------------------------------------- {{{
noremap <F1> <nop>
noremap <K> <nop>

" }}}
" Disable Arrow Keys ------------------------------------------------------- {{{
nnoremap <Left> <Nop>
nnoremap <Right> <Nop>
nnoremap <Up> <Nop>
nnoremap <Down> <Nop>

" }}}
" Defaults for tabs, spaces, & wrapping ------------------------------------ {{{
set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab
set wrap
set textwidth=80
set formatoptions=croqln
call ToggleColorColumn('on')

" }}}
" Backups & State ---------------------------------------------------------- {{{
set backupdir=$HOME/.vimdata/vimbackup/
set directory=$HOME/.vimdata/vimswap/
set viewdir=$HOME/.vimdata/vimviews/
if exists('&undofile')
    set undodir=$HOME/.vimdata/vimundo/
endif

" }}}
" Wildmode ----------------------------------------------------------------- {{{
set wildmenu
set wildmode=longest:full,list:full

set wildignore+=.git,.hg,.svn,CVS
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg
set wildignore+=*.o,*.so
set wildignore+=*.sw?
set wildignore+=*.DS_Store
set wildignore+=*.pyc,*.pyo

" }}}
" Colorscheme -------------------------------------------------------------- {{{
" colorscheme wombat256
colorscheme Tomorrow-Night

if &t_Co < 16
    set t_Co=16
endif

" Useful when debugging colors. It identifies highlight groups
" map <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
            " \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
            " \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver20-Cursor-blinkon600-blinkoff600
set guicursor+=n-v-c:block-Cursor-blinkon600-blinkoff600

" }}}
" Leaders ------------------------------------------------------------------ {{{
let mapleader = ","
let localleader = '\\'

" }}}
" AutoCommands ------------------------------------------------------------- {{{

" If we change focus away from vim, goto normal mode
" do the same if we're in insert mode for 15 seconds
" feedback on the statusline that we're in insert mode
augroup exit_insert_mode
    au!
    au FocusLost,TabLeave * call feedkeys("\<C-\>\<C-n>")
    au CursorHoldI * stopinsert
    au InsertEnter * let updaterestore=&updatetime | set updatetime=15000
    au InsertLeave * let &updatetime=updaterestore
augroup END

" This may cause a lot of processing, but we can disable it if it causes problems
augroup showmarks
    au!
    au BufWinEnter * execute 'ShowMarksOn'
    au BufEnter    * execute 'ShowMarksOn'
    au CursorMoved * execute 'ShowMarksOn'
    au InsertEnter * execute 'ShowMarksOn'
    au InsertLeave * execute 'ShowMarksOn'
augroup END

" Equal all folds on resize
augroup resize
    au!
    au VimResized * exe "normal! \<c-w>="
augroup END

augroup cursor
    au!
    au WinEnter,VimEnter,BufNewFile,BufRead * setlocal cursorline
    au WinLeave,VimLeave * setlocal nocursorline
augroup END

augroup vimmemory
    au!
    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " Also don't do it when the mark is in the first line, that is the default
    " position when opening a file.
    au BufReadPost *
                \ if line("'\"") > 1 && line("'\"") <= line("$")  |
                \   exe "normal! g`\"" |
                \ endif
    " use views to restore more state
    au BufWinLeave * silent! mkview
    au BufWinEnter * silent! loadview
augroup END

augroup templates
    au!
    autocmd! BufNewFile * silent! 0r ~/.vim/skel/tmpl.%:e
augroup END

augroup nerdtree
    au!
    autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()
augroup END

augroup detection
    au!
    autocmd BufReadPost,BufWritePost * filetype detect
augroup END
" }}}
" Toggles & Switches (Leader commands) ------------------------------------- {{{

" zT will move the current line to 1/4th from the top of the window
nnoremap <expr> zT 'zt' . winheight(0)/4 . '<c-y>'
" zB will move the current line to 1/4th from the bottom of the window
nnoremap <expr> zB 'zb' . winheight(0)/4 . '<c-e>'

nnoremap <leader>v :vsplit<cr>
nnoremap <leader>h :split<cr>

"C-{hjkl} to move text or text blocks left down up or right
inoremap <C-j> <Esc>:m+<CR>==gi
inoremap <C-k> <Esc>:m-2<CR>==gi
inoremap <C-h> <Esc><<`]a
inoremap <C-l> <Esc>>>`]a
vnoremap <C-j> :m'>+<CR>gv=gv
vnoremap <C-k> :m-2<CR>gv=gv
vnoremap <C-h> <gv
vnoremap <C-l> >gv

noremap <Leader>c :close<cr>

" <space> switches to the next window (give it a second)
" <space>n switches to the next window
" <space><space> switches to the next window and maximizes it
" <space>= Equalizes the size of all windows
" + Increases the size of the current window
" - Decreases the size of the current window
noremap <space> <c-W>wzz:call PulseCursorLine()<cr>
noremap <space>n <c-W>wzz:call PulseCursorLine()<cr>
noremap <space><space> <C-W>w<C-W>_zz:call PulseCursorLine()<cr>
noremap <space>= <c-W>=zz:call PulseCursorLine()<cr>
if bufwinnr(1)
    noremap + <c-W>+
    noremap - <c-W>-
endif

" Easier navigation between open windows
nnoremap <C-k> <C-W>kzz:call PulseCursorLine()<cr>
nnoremap <C-j> <C-W>jzz:call PulseCursorLine()<cr>
nnoremap <C-h> <C-W>hzz:call PulseCursorLine()<cr>
nnoremap <C-l> <C-W>lzz:call PulseCursorLine()<cr>
nnoremap <C-Right> <C-W>lzz:call PulseCursorLine()<cr>
nnoremap <C-Left> <C-W>hzz:call PulseCursorLine()<cr>
nnoremap <C-Up> <C-W>kzz:call PulseCursorLine()<cr>
nnoremap <C-Down> <C-W>jzz:call PulseCursorLine()<cr>

" Reselect visually selected text after indenting
vnoremap > >gv
vnoremap < <gv

" Select the last edited/pasted text
nnoremap gv `[v`]
nnoremap <Leader>= <C-W>=
nnoremap <Leader>> <C-W>>
nnoremap <Leader>< <C-W><
" make Y consistant with C and D
noremap Y y$

" Change buffers with tab and shift-tab
noremap <tab> :bn<cr>
noremap <s-tab> :bp<cr>

" Easily modify vimrc
nnoremap <leader>ev :e $MYVIMRC<CR>
nnoremap <leader>egv :e$MYGVIMRC<CR>
nnoremap <leader>sv :so $MYVIMRC<CR>
nnoremap <leader>sgv :so $MYGVIMRC<CR>

" Move visually selected lines down/up
vnoremap <C-Down> ]egv
vnoremap <C-Up> [egv

" Move visual selection back/forwards
set ww+=<,>
vnoremap <C-Left> x<Left>P`[v`]
vnoremap <C-Right> x<Right>P`[v`]

" My main typos, these arent used in commands so why not?
cnoremap WQ wq
cnoremap wQ wq

" sudo write-file in case you opened a file you dont have privileges to write
cmap w!! w !sudo tee % >/dev/null<cr>

" Smarter Pasting!
nnoremap <Leader>P :set paste<CR>"*p;set nopaste<CR>

if has('mac')
    nnoremap <leader>o :silent !open <c-r>=escape("<c-r><c-f>", "#?&;\|%")<cr><cr>
else
    nnoremap <leader>o :silent !xdg-open <c-r>=escape("<c-r><c-f>", "#?&;\|%")<cr><cr>
endif

" }}}
" Custom commands and functions -------------------------------------------- {{{
" Window Snapping {{{
nnoremap <silent> <leader>mw :call MarkWindowSwap()<CR>
nnoremap <silent> <leader>pw :call DoWindowSwap()<CR>

" }}}
" Diff against whats on disk {{{
nnoremap <Leader>do :call DiffOrig()<CR>
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif

" }}}
" Toggles for location and quickfix window {{{
nnoremap <silent> <leader>ll :call ToggleList("Location List", 'l')<CR>
nnoremap <silent> <leader>qf :call ToggleList("Quickfix List", 'c')<CR>

" }}}
" Strip trailing whitespaces  {{{
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction
nnoremap _$ :call Preserve("%s/\\s\\+$//e")<CR>
nnoremap _= :call Preserve("normal gg=G")<CR>

" }}}
" Search for current visual selection with */# {{{
" Tip tip from: http://amix.dk/blog/viewEntry/19334
function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" }}}
" Generate a color pallette {{{
function! Colorize()
    let num = 255
    while num >= 0
        exec 'hi col_'.num.' ctermbg='.num.' ctermfg=white'
        exec 'syn match col_'.num.' "ctermbg='.num.':...." containedIn=All'
        call append(0, 'ctermbg='.num.':....')
        let num = num - 1
    endwhile
endfunction

" }}}
" Pasting Buffers {{{
fu! PasteWindow(direction)
    if exists("g:yanked_buffer")
        if a:direction == 'edit'
            let temp_buffer = bufnr('%')
        endif

        exec a:direction . " +buffer" . g:yanked_buffer

        if a:direction == 'edit'
            let g:yanked_buffer = temp_buffer
        endif
    endif
endf

"yank/paste buffers
" :nnoremap <silent> <leader>wy  :let g:yanked_buffer=bufnr('%')<cr>
" :nnoremap <silent> <leader>wd  :let g:yanked_buffer=bufnr('%')<cr>:q<cr>
" :nnoremap <silent> <leader>wp :call PasteWindow('edit')<cr>
" :nnoremap <silent> <leader>ws :call PasteWindow('split')<cr>
" :nnoremap <silent> <leader>wv :call PasteWindow('vsplit')<cr>

" }}}
"
" }}}
" Configure plugins  ------------------------------------------------------- {{{
" Ctrl+P ------------------------------------------------------------------ {{{
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir']
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_cache_dir = $HOME.'/.vimdata/ctrlp'
let g:ctrlp_max_depth = 10
nnoremap <c-b> :CtrlPBuffer<CR>
nnoremap <c-r> :CtrlPMRU<CR>
nnoremap <c-t> :CtrlPBufTagAll<CR>
nnoremap <c-q> :CtrlPQuickfix<CR>
" }}}
" TagList ----------------------------------------------------------------- {{{
noremap <leader>t :TagbarToggle<CR>
" }}}
" Powerlines -------------------------------------------------------------- {{{
let g:Powerline_cache_file = expand('~') . "/.vimdata/powerline.cache"
let g:Powerline_symbols = 'unicode'

" }}}
" Yankring ---------------------------------------------------------------- {{{
let g:yankring_history_dir="$HOME/.vimdata"
let g:yankring_replace_n_pkey = '<M-P>'
nnoremap <leader>y :YRShow<cr>
nnoremap <c-y> :YRShow<CR>

" }}}
" Tabularize  ------------------------------------------------------------- {{{
vnoremap <silent> <Leader>a=> :Tabularize /=>/l1l1<CR>
vnoremap <silent> <Leader>a= :Tabularize /=/l1l1<CR>
vnoremap <silent> <Leader>a, :Tabularize /,/l0l1<CR>
vnoremap <silent> <Leader>a: :Tabularize /:/l0l1<CR>

" }}}
" Simplenote -------------------------------------------------------------- {{{
source ~/.simplenoterc
noremap <Leader>sl :Simplenote -l<CR>
noremap <Leader>sn :Simplenote -n<CR>

" }}}
" Showmarks --------------------------------------------------------------- {{{
let g:showmarks_enable=1
let g:showmarks_include="'`\"^<>.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789[](){}"
let g:showmarks_ignore_type=''
let g:showmarks_textlower="\t"
let g:showmarks_textupper="\t"
let g:showmarks_textother="\t"

" }}}
" bufkill ----------------------------------------------------------------- {{{
noremap <Leader>k :bd<CR>
noremap <Leader>k! :bd!<CR>

" }}}
" Ack --------------------------------------------------------------------- {{{
noremap <Leader>g :Ack<space><C-r><C-w><CR>
let ackprg="~/scripts/ack"
"let ackprg="~/scripts/ack --nocolor --nogroup --column --flush"

" }}}
" NERDCommenter ----------------------------------------------------------- {{{
" When we comment something with the NERDComment Toggle, reselect
let g:NERDCreateDefaultMappings = 0
let g:NERDSpaceDelims = 1
vmap <leader>cc <plug>NERDCommenterToggle<cr>vgv
nmap <leader>cc <plug>NERDCommenterToggle
vmap <leader>cb <plug>NERDCommenterSexy<cr>vgv
nmap <leader>cb <plug>NERDCommenterSexy
vmap <leader>c<space> <plug>NERDCommenterToggle<cr>vgv
nmap <leader>c<space> <plug>NERDCommenterToggle
nmap <leader>c$ <plug>NERDCommenterToEOL

" }}}
" NERDTree.vim ------------------------------------------------------------ {{{
let g:NERDTreeUseExistingWindows = 1
let NERDTreeIgnore=['\~$', '\.swp$', '^CVS$', '\.svn$', '^CVSROOT$', '^\.git$', '\.pyc$', '\.pyo$', '\.swp$']
noremap <Leader>dd :NERDTreeToggle<CR>
noremap <Leader>df :NERDTreeFind<CR>
let NERDTreeShowBookmarks=0
let NERDTreeQuitOnOpen=0
let NERDTreeHighlightCursorLine=0
let NERDTreeHijackNetrw=1

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
        if bufwinnr(t:NERDTreeBufName) != -1
            if winnr("$") == 1
                q
            endif
        endif
    endif
endfunction

" }}}
" Scratch ----------------------------------------------------------------- {{{
noremap <leader>s :call ToggleMyScratch()<CR>

" }}}
" Supertab ----------------------------------------------------------------{{{
let g:SuperTabDefaultCompletionType = "context"

" }}}
" }}}
" Load abbreviations ------------------------------------------------------- {{{
if filereadable(expand("~/.vim/abbrev"))
    source ~/.vim/abbrev
endif

" }}}
" Modelines: --------------------------------------------------------------- {{{
" vim: nowrap fdm=marker ft=vim
"
" }}}
