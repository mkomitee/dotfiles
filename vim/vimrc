" Configure Bundler
set rtp+=~/.vim/bundle/vundle
call vundle#rc()
filetype on
filetype plugin on
filetype indent on
syntax enable

" Load Plugins 
Bundle 'gmarik/vundle'
Bundle 'Lokaltog/vim-easymotion'
Bundle 'Rainbow-Parenthsis-Bundle'
Bundle 'ajf/puppet-vim'
Bundle 'altercation/vim-colors-solarized'
Bundle 'godlygeek/tabular'
Bundle 'kien/ctrlp.vim'
Bundle 'majutsushi/tagbar'
Bundle 'mkomitee/ShowMarks'
Bundle 'mkomitee/puppet-eyes'
Bundle 'scrooloose/nerdcommenter'
Bundle 'scrooloose/nerdtree'
Bundle 'sjl/splice.vim'
Bundle 'tmatilai/gitolite.vim'
Bundle 'tpope/vim-fugitive'
Bundle 'tpope/vim-markdown'
Bundle 'tpope/vim-surround'

" Prepare our vim cache directories
silent execute '!mkdir -p $HOME/.vimdata/vimbackup'
silent execute '!mkdir -p $HOME/.vimdata/vimswap'
silent execute '!mkdir -p $HOME/.vimdata/vimviews'
silent execute '!mkdir -p $HOME/.vimdata/vimundo'
silent execute '!mkdir -p $HOME/.vimdata/ctrlp'

" Preferences 
set encoding=utf-8               " Prefer utf-8 character encoding
set fileformats=unix,mac,dos     " Prefer unix style EOL's
set autoindent                   " Try to line up code intelligently
set showmode                     " Inform me as to what mode im in
set showcmd                      " Show partial commands
set hidden                       " Allow for hidden buffers
set noerrorbells                 " shutup
set novisualbell                 " shutup
set ttyfast                      " it's 2012. Send more characters, faster
set backspace=indent,eol,start   " Nothing is too sacred to be <BS>
set laststatus=2                 " Every window always gets a statusline
set history=10000                " Keep a lot of ex commands in history
set list                         " show invisibles
set listchars=                   " reset listchars
set listchars+=tab:▸\            " display tabs
set listchars+=eol:¶             " display eol
set listchars+=extends:❯         " hint that theres more to the right, ...
set listchars+=precedes:❮        " hint that theres more to the left, ...
set listchars+=trail:♦           " and indicate trailing whitespace
set showbreak=↪                  " indicate a line is the continuation of a
                                 " wrapped line
set matchtime=3                  " show matching parenthesis for 3/10 of a second
set showmatch                    " show matching parenthesis
set splitbelow                   " new horizontal splits to below
set splitright                   " new vertical splits goto the right
set fillchars=                   " reset fillchars
set fillchars+=fold:-            " fill foldtext with dashes
set fillchars+=diff:⣿            " indicate deleted lines in diffs with ⣿
set fillchars+=vert:❚            " indicate vertical splits with ❚
set shiftround                   " round indent to multiples of shiftwidth
set autoread                     " reread files which changes on disk if they
                                 " havnt changed in the buffer
set showfulltag                  " when completing a word from a tags file,
                                 " include extra info about the tag in the
                                 " completion menu
set shortmess=                   " reset shortmess
set shortmess+=f                 " '(3 of 5)' instead of '(file 3 of 5)'
set shortmess+=i                 " '[noeol] instead of '[Incompelte last line]'
set shortmess+=l                 " '999L, 888C' instead of '999 lines, 888 characters'
set shortmess+=m                 " '[+]' instead of '[Modified]'
set shortmess+=n                 " '[New]' instead of '[New File]'
set shortmess+=r                 " '[RO]' instead of '[readonly]'
set shortmess+=w                 " '[w]' instead of 'written'
                                 "  '[a]' instead of 'appended'
set shortmess+=x                 " '[dos]' instead of '[dos format]',
                                 "  '[unix]' instead of '[unix format]',
                                 "  '[mac]' instead of '[mac format]'
set shortmess+=o                 " overwrite message for writing a file with subsequent 
                                 "  message for reading a file (useful for ":wn" or when 
                                 "  'autowrite' on)
set shortmess+=O                 " message for reading a file overwrites any previous 
                                 "  message. Also for quickfix message (e.g., ":cn").
set shortmess+=t                 " truncate file message at the start if it is too long 
                                 "  to fit on the command-line, "<" will appear in the 
                                 "  left most column. Ignored in Ex mode.
set shortmess+=T                 " truncate other messages in the middle if they are too 
                                 "  long to fit on the command line.  "..." will appear 
                                 "  in the middle. Ignored in Ex mode.
set shortmess+=I                 " don't give the intro message when starting Vim |:intro|.
set foldlevelstart=99            " Start with all folds open
set nojoinspaces                 " Don't be fancy with join
set dictionary=/usr/share/dict/words        " for spell checking
set spellfile=~/.dotfiles/vim/en.utf-8.add  " to add words
set spelllang=en_us              " yes, i do speak it
set number                       " line numbers
set iskeyword-=:                 " treat : as a keyword
set iskeyword-=;                 " treat ; as a keyword
set iskeyword-=,                 " treat , as a keyword
set iskeyword+=_                 " treat _ as a keyword
set diffopt=                     " reset diffopt
set diffopt+=filler              " add filler to diff to keep text synchronized
set diffopt+=iwhite              " ignore white space in diff
set updatecount=10               " update swap files every 10 chars
set completeopt=                 " reset completeopt
set completeopt+=longest         " insert the longest match
set completeopt+=menu            " show the menu when there are matches
set completeopt+=menuone         " even if there's only one
set nostartofline                " don't move the cursor to the start of the 
                                 " line when we move vertically in the buffer
set viminfo=                     " reset viminfo settings
set viminfo+='100                " remember marks from last 100 files
set viminfo+=<50                 " remember up to 50 register contents
set viminfo+=s10                 " forget registers > 10kB
set viminfo+=h                   " don't restore hlsearch
set viminfo+=n~/.vimdata/viminfo " move the viminfo file into ~/.vimdata
set pumheight=10                 " show no more than 10 entries in completion menus
set report=0                     " always show how many lines are changed
set switchbuf=                   " reset switchbuf
set switchbuf+=useopen           " switch to a window with the file on open instead 
                                 " of opening it in a second window
set switchbuf+=usetab            " switch to another tab with the file open instead
                                 " of opening it in a second window
set scrolloff=5                  " keep at least 5 lines of context when scrolling
set sidescrolloff=10             " keep at least 10 characters of context when scrolling
set sidescroll=1                 " scroll horizontally by 1
set virtualedit=                 " reset virtualedit
set virtualedit+=block           " can move past the end of the line in visual block mode
set virtualedit+=insert          " can move past the end of the line in insert mode
set incsearch                    " search as I type
set ignorecase                   " ignore case when searching, ...
set smartcase                    " unless I search for uppercase
set hlsearch                     " and highlight searches
set gdefault                     " replace all occurrances on the line by default
set tabstop=4                    " 4 space tabs
set shiftwidth=4                 " indentation uses 4 spaces as well e.g. >>
set expandtab                    " uses spaces, not tabs
set softtabstop=2                " use 2 spaces when tabbing because, ...
set smarttab                     " use softtabstop when tabbing when not at start of line
set wrap                         " wrap long lines in the window (not the file)
set textwidth=80                 " break long lines after 80 chars
set formatoptions=               " reset formatoptions
set formatoptions+=c             " autowrap comments using textwidth
set formatoptions+=r             " insert comment after hitting enter in a comment
set formatoptions+=o             " insert comment after 'o' or 'O' in normal mode
set formatoptions+=q             " format comments with gq
set formatoptions+=n             " recognize numbered lists
set backupdir=$HOME/.vimdata/vimbackup/ " save backups in alternate location
set directory=$HOME/.vimdata/vimswap/   " save swap files here
set viewdir=$HOME/.vimdata/vimviews/    " save views here
set wildmenu                     " commandline completion is nice
set wildmode=                    " reset wildmode
set wildmode+=longest:full       " complete til longest string, use wildmenu
set wildmode+=list:full          " when more than one matchm list all and complete the 
                                 " first
set wildignore+=.git,.hg,.svn,CVS              " ignore vcs directories
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg " ignore images
set wildignore+=*.o,*.so,*.out                 " ignore compiled objects
set wildignore+=*.sw?                          " ignore swap files
set wildignore+=*.DS_Store                     " ignore mac crap
set wildignore+=*.pyc,*.pyo                    " ignore pyton compiled objects

if has('mouse')
    set mouse=a
endif

if exists('&undofile')
    set undofile         " Save undo history to a file for persistence
    set undoreload=10000 " Save the whole buffer for undo when reloading
    set undolevels=10000 " Save lots of data for undo
    set undodir=$HOME/.vimdata/vimundo/
endif



" j and k will go one line, even if they're wrapped
nnoremap j gj
nnoremap k gk

" when using marks, all by default mark columns as well
nnoremap ' `

" Backups & State 

" Wildmode 

" Typos 
command! -bang E e<bang>
command! -bang Q q<bang>
command! -bang W w<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang Wa wa<bang>
command! -bang WA wa<bang>
command! -bang Wq wq<bang>
command! -bang WQ wq<bang>

" Colorscheme 
if has('mac')
    set background=light
    let g:solarized_termtrans = 1
    colorscheme solarized
    call togglebg#map("<F5>")
    hi SignColumn    ctermfg=10 ctermbg=15
    hi ShowMarksHLl  ctermfg=1  ctermbg=15
    hi ShowMarksHLu  ctermfg=9  ctermbg=15
    hi ShowMarksHLo  ctermfg=5  ctermbg=15
    hi ShowMarksHLm  ctermfg=6  ctermbg=15
    hi StatusLine    ctermbg=3  ctermfg=7
    hi StatusLineNC  ctermbg=2  ctermfg=7
else
    set background=dark
    let g:solarized_termtrans = 1
    colorscheme solarized
    call togglebg#map("<F5>")
    hi SignColumn    ctermfg=10 ctermbg=0
    hi ShowMarksHLl  ctermfg=1  ctermbg=0
    hi ShowMarksHLu  ctermfg=9  ctermbg=0
    hi ShowMarksHLo  ctermfg=5  ctermbg=0
    hi ShowMarksHLm  ctermfg=6  ctermbg=0
    hi StatusLine    ctermbg=3  ctermfg=0
    hi StatusLineNC  ctermbg=3  ctermfg=8
endif

set statusline=          " clear statusline
set statusline+=%F\      " full filename
set statusline+=%m%r%w   " flags
set statusline+=%y\      " filetype
set statusline+=%=       " seperator
set statusline+=c:%c\    " column
set statusline+=l:%l/%L\ " line
set statusline+=(%p%%)   " percentage thru file

" Highlight VCS conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" Use a bar-shaped cursor for insert mode, even through tmux.
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
endif
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver20-Cursor-blinkon600-blinkoff600
set guicursor+=n-v-c:block-Cursor-blinkon600-blinkoff600
set ww+=<,>

" Leaders 
let mapleader = ","
let localleader = '\\'

" AutoCommands 
" This may cause a lot of processing, but we can disable it if it causes problems
augroup showmarks
    au!
    au BufWinEnter * execute 'ShowMarksOn'
    au BufEnter    * execute 'ShowMarksOn'
    au CursorMoved * execute 'ShowMarksOn'
augroup END

augroup nerdtree
    au!
    autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()
augroup END

augroup vimmemory
    au!
    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " Also don't do it when the mark is in the first line, that is the default
    " position when opening a file.
    au BufReadPost *
                \ if line("'\"") > 1 && line("'\"") <= line("$")  |
                \   exe "normal! g`\"" |
                \ endif
    " use views to restore more state
    au BufWinLeave * silent! mkview
    au BufWinEnter * silent! loadview
augroup END


" Toggles & Switches (Leader commands) 

nnoremap // :nohl<cr>

if bufwinnr(1)
    noremap + <c-W>+
    noremap - <c-W>-
endif

" Easier navigation between open windows
nnoremap <C-k> <C-W>k
nnoremap <C-j> <C-W>j
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l

" Reselect visually selected text after indenting
vnoremap > >gv
vnoremap < <gv

" Select the last edited/pasted text
nnoremap gv `[v`]
nnoremap <Leader>= <C-W>=

" make Y consistant with C and D
noremap Y y$

" Easily modify vimrc
nnoremap <leader>ev :e $MYVIMRC<CR>
nnoremap <leader>egv :e$MYGVIMRC<CR>
nnoremap <leader>sv :so $MYVIMRC<CR>
nnoremap <leader>sgv :so $MYGVIMRC<CR>


" sudo write-file in case you opened a file you dont have privileges to write
cmap w!! w !sudo tee % >/dev/null<cr>

" Smarter Pasting!
nnoremap <Leader>P :set paste<CR>"*p;set nopaste<CR>

" Custom commands and functions 
" Diff against whats on disk 
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif

"
" Configure plugins  
" Ctrl+P 
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir']
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_cache_dir = $HOME.'/.vimdata/ctrlp'
let g:ctrlp_max_depth = 10
let g:ctrlp_mruf_relative = 1
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_open_new_file = 'r'
let g:ctrlp_open_multi = '1vr'
let g:ctrlp_dont_split = 'netrw\|help'
nnoremap <c-b> :CtrlPBuffer<CR>
nnoremap <leader>b :CtrlPBuffer<CR>
nnoremap <leader>r :CtrlPMRU<CR>
nnoremap <leader>q :CtrlPQuickfix<CR>
nnoremap <leader>t :CtrlPTag<CR>
nnoremap <leader>l :CtrlPTag<CR>
" Tabularize  
vnoremap <silent> <Leader>a=> :Tabularize /=>/l1l1<CR>
vnoremap <silent> <Leader>a= :Tabularize /=/l1l1<CR>
vnoremap <silent> <Leader>a, :Tabularize /,/l0l1<CR>
vnoremap <silent> <Leader>a: :Tabularize /:/l0l1<CR>

" Showmarks 
let g:showmarks_enable=1
let g:showmarks_include="'`\"^<>.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789[](){}"
let g:showmarks_ignore_type=''
let g:showmarks_textlower="\t"
let g:showmarks_textupper="\t"
let g:showmarks_textother="\t"

" NERDCommenter 
" When we comment something with the NERDComment Toggle, reselect
let g:NERDCreateDefaultMappings = 0
let g:NERDTreeMinimalUI = 1
let g:NERDTreeDirArrows = 1

let g:NERDSpaceDelims = 1
vmap <leader>cc <plug>NERDCommenterToggle<cr>vgv
nmap <leader>cc <plug>NERDCommenterToggle
vmap <leader>cb <plug>NERDCommenterSexy<cr>vgv
nmap <leader>cb <plug>NERDCommenterSexy
nmap <leader>c<space> <plug>NERDCommenterToggle
vmap <leader>c<space> <plug>NERDCommenterToggle<cr>vgv
nmap <leader>c$ <plug>NERDCommenterToEOL

" NERDTree.vim 
let g:NERDTreeUseExistingWindows = 1
let NERDTreeIgnore=['\~$', '\.swp$', '^CVS$', '\.svn$', '^CVSROOT$', '^\.git$', '\.pyc$', '\.pyo$', '\.swp$']
noremap <Leader>dd :NERDTreeToggle<CR>
noremap <Leader>df :NERDTreeFind<CR>
let NERDTreeShowBookmarks=0
let NERDTreeQuitOnOpen=0
let NERDTreeHighlightCursorLine=0
let NERDTreeHijackNetrw=1

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
        if bufwinnr(t:NERDTreeBufName) != -1
            if winnr("$") == 1
                q
            endif
        endif
    endif
endfunction

" Load abbreviations 
if filereadable(expand("~/.vim/abbrev"))
    source ~/.vim/abbrev
endif

" Modelines: 
" vim: nowrap fdm=marker ft=vim
"
