
" Folding cheet sheet
" zR    open all folds
" zM    close all folds
" za    toggle fold at cursor position
" zj    move down to start of next fold
" zk    move up to end of previous fold

" Load Plugins. {{{1
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

" Setup directories {{{1
silent execute '!mkdir -p $HOME/.vimdata/vimbackup'
silent execute '!mkdir -p $HOME/.vimdata/vimswap'
silent execute '!mkdir -p $HOME/.vimdata/vimviews'
silent execute '!mkdir -p $HOME/.vimdata/fufdata'

" Preferences {{{1
" Use Vim settings, rather then Vi settings (much better!).
" This must be first, because it changes other options as a side effect.
filetype plugin on
filetype plugin indent on
set showfulltag
set cmdheight=1
set nocompatible
set backspace=indent,eol,start
set history=10000       " keep lots of command line history
set undolevels=10000    " lots of undoing too
set showcmd             " display incomplete commands
set incsearch           " do incremental searching
set novisualbell 
set t_vb=    " no beep or bell
set number              " line numbers
set tabstop=4           " Tab counts as 4 spaces
set softtabstop=4       " Soft tabs ARE 4 spaces
set shiftwidth=4        " Autoindent using 4 spaces
set textwidth=100
set expandtab           " Expand tabs to spaces
set hidden              " buffers not in the foreground are hidden
set nowrap              " No wrapping
set backupdir=$HOME/.vimdata/vimbackup/ " backup files
set directory=$HOME/.vimdata/vimswap/   " swap files
set viewdir=$HOME/.vimdata/vimviews/    " view files
set laststatus=2        " always show the status line
set clipboard=unnamedplus,unnamed,autoselect
set scrolloff=5         " keep 5 lines for context while scrolling
set sidescrolloff=5     " same for left-right
set splitbelow          " drr
set ignorecase          " case insensitive searching, ...
set smartcase           " unless the search term includes a capital
set title               " vim changes xterm window title
set foldcolumn=2        " add 2 to the gutter to show folds
set shortmess+=filmnrxoOtTI
set iskeyword-=:
set iskeyword-=;
set iskeyword-=,
set iskeyword+=_
set listchars=precedes:<,extends:>,tab:\|-,trail:Â·
set virtualedit=block
set display+=lastline
set nolist
set wildmenu
set nowarn
set diffopt=filler,iwhite
set autoread
"set complete=.,w,b,u,U,t,i,d
set ttyfast
set fileformats=unix,mac,dos
set updatecount=10
set completeopt=longest,menu,menuone
set wildmode=longest:full,list:full
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*.so,*/CVS/*,*.pyc,*.pyo,.*
set switchbuf=usetab
set lazyredraw
set showcmd
set showmode
set nostartofline
" set showtabline=2
syntax enable
set background=dark
colorscheme solarized
set shiftround
set magic
set matchpairs+=<:>
if &t_Co < 16
    set t_Co=16
endif
set viminfo='100,<50,s10,h,n~/.vimdata/viminfo
" n is the viminfo filename
" Configure ColorColumn
hi ColorColumn guibg=#191919 gui=BOLD ctermbg=NONE cterm=BOLD

" Configure Cursor Blinking
set guicursor=n-v-c:block-Cursor
set guicursor+=i:ver20-Cursor-blinkon600-blinkoff600
set guicursor+=n-v-c:block-Cursor-blinkon600-blinkoff600

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
    set mouse=a
endif

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
syntax on
set hlsearch

" Statusline {{{1
set statusline=   " clear the statusline for when vimrc is reloaded
set statusline+=%#KomiteeStatus#
set statusline+=[%n]\                      " buffer number
set statusline+=%<%.99f\                     " file name
set statusline+=%#warningmsg#
set statusline+=%{SyntasticStatuslineFlag()}
set statusline+=%*
set statusline+=%h%m%r%w                     " flags
set statusline+=[%{strlen(&ft)?&ft:'none'},  " filetype
set statusline+=%{strlen(&fenc)?&fenc:&enc}, " encoding
set statusline+=%{&fileformat}               " file format
set statusline+=%{HasPaste()}]               " whether we're in paste mode
set statusline+=%{fugitive#statusline()}     " git branch
set statusline+=%=                           " right align
set statusline+=col:%v\                      " current column
set statusline+=lin:%l/%L\                   " line
set statusline+=%p%%                         " percentage through file

function! HasPaste()
    if &paste
        return ',paste'
    else
        return ''
    endif
endfunction


" AutoCommands {{{1

" If we change focus away from vim, goto normal mode
" do the same if we're in insert mode for 15 seconds
augroup exit_insert_mode
    au!
    au FocusLost,TabLeave * call feedkeys("\<C-\>\<C-n>")
    au CursorHoldI * stopinsert
    au InsertEnter * let updaterestore=&updatetime | set updatetime=15000
    au InsertLeave * let &updatetime=updaterestore
augroup END

augroup cursor
    au!
    au WinEnter,VimEnter,BufNewFile,BufRead * setlocal cursorline
    au WinLeave,VimLeave * setlocal nocursorline
    " au WinEnter,VimEnter,BufNewFile,BufRead * setlocal cursorcolumn
    " au WinLeave,VimLeave * setlocal nocursorcolumn
augroup END

augroup vimmemory
    au!
    " When editing a file, always jump to the last known cursor position.
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " Also don't do it when the mark is in the first line, that is the default
    " position when opening a file.
    au BufReadPost *
                \ if line("'\"") > 1 && line("'\"") <= line("$")  |
                \   exe "normal! g`\"" |
                \ endif
    " use views to restore more state
    au BufWinLeave * silent! mkview
    au BufWinEnter * silent! loadview
augroup END

augroup templates
    au!
    autocmd! BufNewFile * silent! 0r ~/.vim/skel/tmpl.%:e
augroup END

augroup nerdtree
    au!
    autocmd WinEnter * call s:CloseIfOnlyNerdTreeLeft()
augroup END

" Toggles & Switches (Leader commands) {{{1
let mapleader = ","
let localleader = '\'

nnoremap <F3> :nohl<return>

" dont reach for escape when in insert mode, just jj
inoremap jj <esc>

" Force yourself to use jk instead of esc
" inoremap <esc> <nop>

" try to use hjkl instead of arrow keys
" nnoremap <Down> <nop>
" nnoremap <Up> <nop>
" nnoremap <Left> <nop>
" nnoremap <Right> <nop>
" inoremap <Down> <nop>
" inoremap <Up> <nop>
" inoremap <Left> <nop>
" inoremap <Right> <nop>

" zT will move the current line to 1/4th from the top of the window
nnoremap <expr> zT 'zt' . winheight(0)/4 . '<c-y>'
" zB will move the current line to 1/4th from the bottom of the window
nnoremap <expr> zB 'zb' . winheight(0)/4 . '<c-e>'

nnoremap <leader>v :vsplit<cr>

" j and k will go one line, even if they're wrapped
nnoremap j gj
nnoremap k gk

" start / end of line should be easier to reach than ^ and $
nnoremap H ^
nnoremap L $



" ; should probably be the start of a command
" nnoremap ; :
"
" when using marks, all by default mark columns as well
nnoremap ' `

" very magic searching by default
" nnoremap / /\v
" nnoremap ? ?\v

"C-{hjkl} to move text or text blocks left down up or right
" nnoremap <C-j> :m+<CR>==
" nnoremap <C-k> :m-2<CR>==
" nnoremap <C-h> <<
" nnoremap <C-l> >>
inoremap <C-j> <Esc>:m+<CR>==gi
inoremap <C-k> <Esc>:m-2<CR>==gi
inoremap <C-h> <Esc><<`]a
inoremap <C-l> <Esc>>>`]a
vnoremap <C-j> :m'>+<CR>gv=gv
vnoremap <C-k> :m-2<CR>gv=gv
vnoremap <C-h> <gv
vnoremap <C-l> >gv

" redraw window so search terms are centered
noremap n nzz
noremap N Nzz

noremap <Leader>c :close<cr>

" <space> switches to the next window (give it a second)
" <space>n switches to the next window
" <space><space> switches to the next window and maximizes it
" <space>= Equalizes the size of all windows
" + Increases the size of the current window
" - Decreases the size of the current window
noremap <space> <c-W>w
noremap <space>n <c-W>w
noremap <space><space> <C-W>w<C-W>_
noremap <space>= <c-W>=
if bufwinnr(1)
    noremap + <c-W>+
    noremap - <c-W>-
endif

" Make cursor move ask i'd expect with wrapped lines:
" nnoremap <Down> gj
" nnoremap <Up> gk
" nnoremap j gj
" nnoremap k gk
" inoremap <Down> <Esc>gji
" inoremap <Up> <Esc>gki

" Open the current buffer in a vertically split window with the next page of
" text on it.
noremap <silent> <Leader>vs ggzR:<C-u>let @z=&so<CR>:set so=0 noscb<CR>:set columns=178<CR>:bo vs<CR>zRLjzt:setl scb<CR><C-w>p:setl scb<CR>:let &so=@z<CR>

" Easier navigation between open windows
nnoremap <C-k> <C-W>k
nnoremap <C-j> <C-W>j
nnoremap <C-h> <C-W>h
nnoremap <C-l> <C-W>l
nnoremap <C-Right> <C-W>lzz
nnoremap <C-Left> <C-W>hzz
nnoremap <C-Up> <C-W>kzz
nnoremap <C-Down> <C-W>jzz

" Reselect visually selected text after indenting
vnoremap > >gv
vnoremap < <gv

" Select the last edited/pasted text
nnoremap gv `[v`]
nnoremap <Leader>= <C-W>=
nnoremap <Leader>> <C-W>>
nnoremap <Leader>< <C-W><
" make Y consistant with C and D
noremap Y y$

" Allow tab completion
"inoremap <Tab> <C-N>
"inoremap <S-Tab> <C-P>

" Change buffers with tab and shift-tab
noremap <Leader><tab> :BufExplorer<cr>
noremap <tab> :bn<cr>
noremap <s-tab> :bp<cr>


" Easily modify vimrc
nnoremap <leader>ev :e $MYVIMRC<CR>
nnoremap <leader>egv :e$MYGVIMRC<CR>
nnoremap <leader>sv :so $MYVIMRC<CR>
nnoremap <leader>sgv :so $MYGVIMRC<CR>

" Move current line down/up
" nnoremap <C-Down> ]e
" nnoremap <C-Up> [e

" Move visually selected lines down/up
vnoremap <C-Down> ]egv
vnoremap <C-Up> [egv

" Move visual selection back/forwards
set ww+=<,>
vnoremap <C-Left> x<Left>P`[v`]
vnoremap <C-Right> x<Right>P`[v`]

" My main typos, these arent used in commands so why not?
cnoremap WQ wq
cnoremap wQ wq

" sudo write-file in case you opened a file you dont have privileges to write
cmap w!! w !sudo tee % >/dev/null<cr>

" Smarter Pasting!
nnoremap <Leader>P :set paste<CR>"*p;set nopaste<CR>

" Custom commands and functions {{{1
function! MarkWindowSwap()
    let g:markedWinNum = winnr()
endfunction

function! DoWindowSwap()
    "Mark destination
    let curNum = winnr()
    let curBuf = bufnr( "%" )
    exe g:markedWinNum . "wincmd w"
    "Switch to source and shuffle dest->source
    let markedBuf = bufnr( "%" )
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' curBuf
    "Switch to dest and shuffle source->dest
    exe curNum . "wincmd w"
    "Hide and open so that we aren't prompted and keep history
    exe 'hide buf' markedBuf 
endfunction

nnoremap <silent> <leader>mw :call MarkWindowSwap()<CR>
nnoremap <silent> <leader>pw :call DoWindowSwap()<CR>


" view diff between current buffer and original file it was loaded from {{{2
nnoremap <Leader>do :call DiffOrig()<CR>

function! DiffOrig()
    if !exists("b:diff_active") && &buftype == "nofile"
        echoerr "E: Cannot diff a scratch buffer"
        return -1
    elseif expand("%") == ""
        echoerr "E: Buffer doesn't exist on disk"
        return -1
    endif

    if !exists("b:diff_active") || b:diff_active == 0
        let b:diff_active = 1
        let l:orig_filetype = &l:filetype

        leftabove vnew
        set buftype=nofile
        read #
        0delete_
        let &l:filetype = l:orig_filetype
        diffthis
        wincmd p
        diffthis
    else
        diffoff
        wincmd p
        bdelete
        let b:diff_active = 0
    endif
endfunction

function! ToggleColorColumn(toggle)
    if exists('+colorcolumn')
        if a:toggle == 'on'
            setlocal colorcolumn=+1,+2,+3,+4,+5,+6,+7,+8,+9,+10
        else
            setlocal colorcolumn=
        endif
    else
    endif
endfunction

" Toggles for location and quickfix window {{{2
function! GetBufferList()
    redir =>buflist
    silent! ls
    redir END
    return buflist
endfunction

function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 'v:val =~ "'.a:bufname.'"'), 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx.'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echomsg "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open')
    if winnr() != winnr
        wincmd p
    endif
endfunction

nnoremap <silent> <leader>ll :call ToggleList("Location List", 'l')<CR>
nnoremap <silent> <leader>qf :call ToggleList("Quickfix List", 'c')<CR>


" Diff between buffer and the unwritten file {{{2
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
                \ | wincmd p | diffthis
endif

" Custom fold text {{{2
" fu! CustomFoldText()
    " "get first non-blank line
    " let fs = v:foldstart
    " while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
    " endwhile
    " if fs > v:foldend
        " let line = getline(v:foldstart)
    " else
        " let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
    " endif

    " let w = winwidth(0) - &foldcolumn - (&number ? 8 : 0)
    " let foldSize = 1 + v:foldend - v:foldstart
    " let foldSizeStr = " " . foldSize . " lines "
    " let foldLevelStr = repeat("+--", v:foldlevel)
    " let lineCount = line("$")
    " let foldPercentage = printf("[%.1f", (foldSize*1.0)/lineCount*100) . "%] "
    " let expansionString = repeat(".", w - strwidth(foldSizeStr.line.foldLevelStr.foldPercentage))
    " return line . expansionString . foldSizeStr . foldPercentage . foldLevelStr
" endf



" Strip trailing whitespaces  {{{2
function! Preserve(command)
    " Preparation: save last search, and cursor position.
    let _s=@/
    let l = line(".")
    let c = col(".")
    " Do the business:
    execute a:command
    " Clean up: restore previous search history, and cursor position
    let @/=_s
    call cursor(l, c)
endfunction
nnoremap _$ :call Preserve("%s/\\s\\+$//e")<CR>
nnoremap _= :call Preserve("normal gg=G")<CR>

" Search for current visual selection with */# {{{2
" Tip tip from: http://amix.dk/blog/viewEntry/19334
function! CmdLine(str)
    exe "menu Foo.Bar :" . a:str
    emenu Foo.Bar
    unmenu Foo
endfunction

function! VisualSearch(direction) range
    let l:saved_reg = @"
    execute "normal! vgvy"

    let l:pattern = escape(@", '\\/.*$^~[]')
    let l:pattern = substitute(l:pattern, "\n$", "", "")

    if a:direction == 'b'
        execute "normal ?" . l:pattern . "^M"
    elseif a:direction == 'gv'
        call CmdLine("vimgrep " . '/'. l:pattern . '/' . ' **/*.')
    elseif a:direction == 'f'
        execute "normal /" . l:pattern . "^M"
    endif

    let @/ = l:pattern
    let @" = l:saved_reg
endfunction

" Generate a color pallette {{{2
function! Colorize()
    let num = 255
    while num >= 0
        exec 'hi col_'.num.' ctermbg='.num.' ctermfg=white'
        exec 'syn match col_'.num.' "ctermbg='.num.':...." containedIn=All'
        call append(0, 'ctermbg='.num.':....')
        let num = num - 1
    endwhile
endfunction

" Pasting Buffers {{{2
fu! PasteWindow(direction)
    if exists("g:yanked_buffer")
        if a:direction == 'edit'
            let temp_buffer = bufnr('%')
        endif

        exec a:direction . " +buffer" . g:yanked_buffer

        if a:direction == 'edit'
            let g:yanked_buffer = temp_buffer
        endif
    endif
endf

"yank/paste buffers
" :nnoremap <silent> <leader>wy  :let g:yanked_buffer=bufnr('%')<cr>
" :nnoremap <silent> <leader>wd  :let g:yanked_buffer=bufnr('%')<cr>:q<cr>
" :nnoremap <silent> <leader>wp :call PasteWindow('edit')<cr>
" :nnoremap <silent> <leader>ws :call PasteWindow('split')<cr>
" :nnoremap <silent> <leader>wv :call PasteWindow('vsplit')<cr>

" Configure plugins {{{1
" Align {{{2
vnoremap <leader>a=> :Align => =<cr>

" Syntastic {{{2
let g:syntastic_enable_signs   = 1
let g:syntastic_auto_jump      = 1
let g:syntastic_auto_loc_list  = 2
" let g:syntastic_quiet_warnings = 1

" ctrlp {{{2
let g:ctrlp_working_path_mode = 0
let g:ctrlp_dotfiles = 0
let g:ctrlp_max_height = 20000
let g:ctrlp_use_caching=1
let g:ctrlp_max_files = 20000

" nnoremap <leader>b :CtrlPBuffer<cr>
" nnoremap <leader>m :CtrlPMRUFiles<cr>

" Bexec {{{2
nnoremap <silent> <unique> <F8> :call Bexec()<cr>
vnoremap <silent> <unique> <F8> :call BexecVisual()<cr>
noremap <silent> <unique> <F9> :call BexecCloseOut()<cr>


" Screen/tmux {{{2
let g:ScreenImpl = 'Tmux'
"
" Simplenote {{{2
source ~/.simplenoterc
noremap <Leader>sl :Simplenote -l<CR>
noremap <Leader>sn :Simplenote -n<CR>

" Lusty {{{2
noremap <Leader>b :LustyBufferExplorer<CR>
noremap <Leader>f :LustyFilesystemExplorer<CR>
noremap <Leader>r :LustyFilesystemExplorerFromHere<CR>
noremap <Leader>j :LustyJuggler<CR>

" AutoClose
noremap <Leader>x <Plug>ToggleAutoCloseMappings

" tagbar {{{2
noremap <leader>t :TagbarToggle<CR>
let g:tagbar_expand = 1
let g:tagbar_sort = 1
let g:tagbar_ctags_use_tagfiles = 1

" Showmarks {{{2
let g:showmarks_enable=1
let g:showmarks_include="abcdefghijklmnopqrstuvwxyz"
let g:showmarks_textlower="\t>"

" bufkill {{{2
noremap <Leader>k :bd<CR>
noremap <Leader>k! :bd!<CR>

" Command-T {{{2
noremap <Leader>ct :CommandT<CR>

" FuzzyFinder {{{2
let g:fuf_modesDisable = []
let g:fuf_dataDir = '~/.vimdata/fufdata'
noremap <Leader>fb :FufBuffer<CR>
noremap <Leader>ff :FufFile<CR>
noremap <Leader>fm :FufMruFile<CR>

" Ack {{{2
noremap <Leader>g :Ack<space><C-r><C-w><CR>
let ackprg="~/scripts/ack"
"let ackprg="~/scripts/ack --nocolor --nogroup --column --flush"

" NERDCommenter {{{2
" When we comment something with the NERDComment Toggle, reselect
let g:NERDCreateDefaultMappings = 0
let g:NERDSpaceDelims = 1
vmap <leader>cc <plug>NERDCommenterToggle<cr>vgv
nmap <leader>cc <plug>NERDCommenterToggle
vmap <leader>cb <plug>NERDCommenterSexy<cr>vgv
nmap <leader>cb <plug>NERDCommenterSexy
vmap <leader>c<space> <plug>NERDCommenterToggle<cr>vgv
nmap <leader>c<space> <plug>NERDCommenterToggle
nmap <leader>c$ <plug>NERDCommenterToEOL


" NERDTree.vim {{{2
let g:NERDTreeUseExistingWindows = 1
let NERDTreeIgnore=['\~$', '\.swp$', '^CVS$', '\.svn$', '^CVSROOT$', '^\.git$', '\.pyc$', '\.pyo$', '\.swp$']
noremap <Leader>dd :NERDTreeToggle<CR>
noremap <Leader>df :NERDTreeFind<CR>
let NERDTreeShowBookmarks=1
let NERDTreeQuitOnOpen=0
let NERDTreeHighlightCursorLine=0
let NERDTreeHijackNetrw=1

" Close all open buffers on entering a window if the only
" buffer that's left is the NERDTree buffer
function! s:CloseIfOnlyNerdTreeLeft()
    if exists("t:NERDTreeBufName")
        if bufwinnr(t:NERDTreeBufName) != -1
            if winnr("$") == 1
                q
            endif
        endif
    endif
endfunction

" notes.vim {{{2
let g:notes_location=glob("~/Docs/Notes")

" Scratch {{{2
function! ToggleMyScratch()
    let file_name     = '~/.scratch'
    let buffer_number = bufnr(file_name)
    let window_number = bufwinnr(buffer_number)
    if buffer_number == -1
        exe 'split' . file_name
    else
        if window_number != -1
            if winnr() != window_number
                exe window_number . "wincmd w"
            else
                write
                quit
            endif
        else
            exe 'split' . file_name
        endif
    endif
endfunction
noremap <leader>s :call ToggleMyScratch()<CR>

" Supertab {{{2
let g:SuperTabDefaultCompletionType = "context"

" Load abbreviations
if filereadable(expand("~/.vim/abbrev"))
    source ~/.vim/abbrev
endif

" Modelines: {{{1
" vim: nowrap fdm=marker ft=vim
" }}}
