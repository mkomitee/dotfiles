" dein scripts
if &compatible
  set nocompatible               " Be iMproved
endif

" Required:
set runtimepath+=~/.vim/bundles/repos/github.com/Shougo/dein.vim

" Required:
if dein#load_state(expand('~/.vim/bundles'))
  call dein#begin(expand('~/.vim/bundles'))

  " Let dein manage dein
  " Required:
  call dein#add(expand('~/.vim/bundles/repos/github.com/Shougo/dein.vim'))

  " Add or remove your plugins here:
  call dein#add('itchyny/lightline.vim')
  call dein#add('junegunn/fzf', { 'build': './install --all' })
  call dein#add('junegunn/fzf.vim')
  call dein#add('kshenoy/vim-signature')
  call dein#add('mhinz/vim-signify')
  call dein#add('morhetz/gruvbox')
  call dein#add('rgarver/Kwbd.vim')
  call dein#add('sheerun/vim-polyglot')
  call dein#add('tpope/vim-commentary')
  call dein#add('tpope/vim-vinegar')
  call dein#add('tpope/vim-endwise')
  call dein#add('tpope/vim-fugitive')
  call dein#add('tpope/vim-repeat')
  call dein#add('tpope/vim-sensible')
  call dein#add('tpope/vim-surround')
  call dein#add('tpope/vim-unimpaired.git')
  call dein#add('w0rp/ale')

  " Required:
  call dein#end()
  call dein#save_state()
endif

" Required:
filetype plugin indent on
syntax enable

" If you want to install not installed plugins on startup.
if dein#check_install()
  call dein#install()
endif

" End dein Scripts

" Preferences
colorscheme gruvbox
let mapleader = " "
let localleader = '\\'

set autoread             " reload files if modified outside of vim & safe
set hidden               " Allow for hidden buffers
set list                 " show invisibles
set showbreak=↪          " indicate a line is the continuation of a wrapped line
set showmatch            " show matching parenthesis
set showcmd              " show partial commands
set foldlevelstart=99    " Start with all folds open
set dictionary=/usr/share/dict/words        " for spell checking
set spellfile=~/.dotfiles/vim/en.utf-8.add  " to add words
set spelllang=en_us      " yes, i do speak it
set spellsuggest=best,10 " only display the 10 best suggestions
set number               " line numbers
set nostartofline        " don't move the cursor to the start of the line when
                         " we move vertically in the buffer
set pumheight=10         " show no more than 10 entries in completion menus
set sidescroll=1         " scroll horizontally by 1
set ignorecase           " ignore case when searching, ...
set smartcase            " unless I search for uppercase
set hlsearch             " and highlight searches
set backupdir=$HOME/.vim/data/vimbackup/ " save backups in alternate location
set directory=$HOME/.vim/data/vimswap/   " save swap files here
set viewdir=$HOME/.vim/data/vimviews/    " save views here
set wildmenu              " commandline completion is nice
set expandtab             " by default, use spaces & no tabs
set shiftwidth=4          " shift width (>> & autoindent)
set softtabstop=4         " 1 tab = 4 spaces
set tabstop=4             " 1 tab = 4 spaces
set textwidth=80          " wrap at 80 columns
set tags=./tags;          " name of the tags files which is relative to the project
set nojoinspaces          " 1 space when joining lines at a period, not 2
set notimeout             " don't timeout mappings
set modeline              " allow vim config in files
set exrc                  " allow local vimrcs
set secure                " limit valid commands in local vimrcs
set autochdir             " change the cwd to that of the current file
set background=dark       " use a dark background
set grepprg=rg\ --vimgrep " use rg for vim-grep
set splitbelow            " split below instead of above
set splitright            " split to the right instead of the left
set colorcolumn=+1        " highlight the color column+1
set breakindent           " visually indent wrapped lines
set undofile              " track undo history
set undodir=$HOME/.vim/data/vimundo/ " place undo history here

set fillchars=         " reset fillchars
set fillchars+=fold:-  " fill foldtext with dashes
set fillchars+=diff:⣿  " indicate deleted lines in diffs with ⣿
set fillchars+=vert:│  " indicate vertical splits with │
set fillchars+=stlnc:━ " indicate horizontal splits with -

set listchars=            " reset listchars
set listchars+=tab:▸▸     " display tabs
set listchars+=extends:❯  " hint that theres more to the right, ...
set listchars+=precedes:❮ " hint that theres more to the left, ...

set shortmess=   " reset shortmess
set shortmess+=f " '(3 of 5)' instead of '(file 3 of 5)'
set shortmess+=i " '[noeol] instead of '[Incompelte last line]'
set shortmess+=l " '999L, 888C' instead of '999 lines, 888 characters'
set shortmess+=m " '[+]' instead of '[Modified]'
set shortmess+=n " '[New]' instead of '[New File]'
set shortmess+=r " '[RO]' instead of '[readonly]'
set shortmess+=w " '[w]' instead of 'written' '[a]' instead of 'appended'
set shortmess+=x " '[dos]' instead of '[dos format]', '[unix]' instead of
                 "  '[unix format]', '[mac]' instead of '[mac format]'
set shortmess+=o " overwrite message for writing a file with subsequent message
                 "  for reading a file (useful for ":wn" or when 'autowrite' on)
set shortmess+=O " message for reading a file overwrites any previous message.
                 "  Also for quickfix message (e.g., ":cn").
set shortmess+=t " truncate file message at the start if it is too long to fit
                 "  on the command-line, "<" will appear in the left most column.
                 "  Ignored in Ex mode.
set shortmess+=T " truncate other messages in the middle if they are too long to
                 "  fit on the command line.  "..." will appear  in the middle.
                 "  Ignored in Ex mode.
set shortmess+=I " don't give the intro message when starting Vim |:intro|.

set completeopt=         " reset completeopt
set completeopt+=longest " insert the longest match
set completeopt+=menuone " show the menu when there are matches

set viminfo+=n~/.vim/data/viminfo " move the viminfo file into ~/.vim/data

set virtualedit=        " reset virtualedit
set virtualedit+=block  " can move past the end of the line in visual block mode
set virtualedit+=insert " can move past the end of the line in insert mode

set formatoptions=   " reset formatoptions
set formatoptions+=c " autowrap comments using textwidth
set formatoptions+=q " format comments with gq
set formatoptions+=n " recognize numbered lists
set formatoptions+=j " joining comments deletes comment leader

set wildignore=                                     " reset wildignore
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*,*/CVS/*   " ignore vcs directories
set wildignore+=*.jpg,*.bmp,*.gif,*.png,*.jpeg      " ignore images
set wildignore+=*.o,*.so,*.out                      " ignore compiled objects
set wildignore+=*.sw?                               " ignore swap files
set wildignore+=*.DS_Store                          " ignore mac crap
set wildignore+=*.pyc,*.pyo                         " ignore compiled python
set wildignore+=*.log,*.LOG                         " ignore log files
set wildignore+=*.[12345678]                        " ignore rotated logs
set wildignore+=*.gz,*.tar,*.tgz,*.bz2,*.cpio,*.rpm " ignore archives
set wildignore+=*.ignore                            " ignore extras

set diffopt=           " reset diffopt
set diffopt+=filler    " add filler
set diffopt+=veritlcal " vertical diff by default

" [S]plit lines (sister to [J]oin line)
function! s:SplitLine()
  exe "normal! i\<CR>\<Esc>^gk"
  silent! substitute/\v +$//
  silent! nohlsearch
  call histdel("search", -1)
  normal! $
endfunction
nnoremap S :call <SID>SplitLine()<CR>

function! Preserve(command)
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Do the business:
  execute a:command
  " Clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction

function! RemoveTrailingWhiteSpace()
    " Allow a buffer local variable trailing_witespace_ok  to permit trailing
    " whitspace -- sometimes I need to do this if im editing someone elses code
    " and don't want to own the entire file in vcs. Enable it with let
    " trailing_witespace_ok=1, disable it with unlet trailing_witespace_ok
    if !exists("b:trailing_whitespace_ok")
        call Preserve("%s/\\s\\+$//e")
    endif
endfun

function! RestoreCursorPosition()
    " Restore cursor position to the last time you were in the file, this uses
    " marks so it's dependent on viminfo
    for ft in ['gitcommit', 'hgcommit', 'cvs', 'svn']
        if &filetype==ft
            return
        endif
    endfor
    normal! g`"
    normal! zz
endfunction

" Try really hard to use the correct syntax highlighting
autocmd BufEnter * :syntax sync fromstart

" Tweak basic navigation
nnoremap <silent> j gj
nnoremap <silent> k gk
nnoremap <silent> $ g$

nnoremap <silent> gj j
nnoremap <silent> gk k
nnoremap <silent> g$ $

onoremap <silent> j gj
onoremap <silent> k gk
onoremap <silent> $ g$

onoremap <silent> gj j
onoremap <silent> gk k
onoremap <silent> g$ $

vnoremap <silent> j gj
vnoremap <silent> k gk
vnoremap <silent> $ g$

vnoremap <silent> gj gj
vnoremap <silent> gk gk
vnoremap <silent> g$ g$

" smart-home: ^ and 0 will toggle between one another {{{
nnoremap <expr> <silent> ^ col('.') == match(getline('.'),'\S')+1 ? 'g0' : 'g^'
vnoremap <expr> <silent> ^ col('.') == match(getline('.'),'\S')+1 ? 'g0' : 'g^'
onoremap <expr> <silent> ^ col('.') == match(getline('.'),'\S')+1 ? 'g0' : 'g^'
nnoremap <expr> <silent> 0 col('.') == 1 ? 'g^' : 'g0'
vnoremap <expr> <silent> 0 col('.') == 1 ? 'g^' : 'g0'
onoremap <expr> <silent> 0 col('.') == 1 ? 'g^' : 'g0'

" When using marks, all by default mark columns as well
nnoremap <silent> ' `

" Simple map to disable highlighting
nnoremap <silent> // :nohl<cr>

" Reselect visually selected text after indenting
vnoremap <silent> > >gv
vnoremap <silent> < <gv

" sudo write-file in case you're in a file you dont have privileges to write{{{
cmap <silent> w!! w !sudo tee % >/dev/null<cr>

" . returns to starting place after repeat
nnoremap <silent> . .`[

" Don't move when you use */#
" https://twitter.com/dotvimrc/status/428208518487764992
nnoremap <silent> * :let b:pos = winsaveview()<cr>*:call winrestview(b:pos)<cr>
nnoremap <silent> # :let b:pos = winsaveview()<cr>#:call winrestview(b:pos)<cr>
"
" File commands
nnoremap <silent> <leader>fed :e $MYVIMRC<CR>
nnoremap <silent> <leader>ff :Files<CR>
nnoremap <silent> <leader>fm :History<CR>

" Project commands
nnoremap <silent> <leader>pf :GFiles<CR>

" Buffer commands
nnoremap <silent> <leader>bb :Buffers<CR>
nnoremap <silent> <leader>bd :Kwbd<CR>
nnoremap <silent> <leader>bn :bnext<CR>
nnoremap <silent> <leader>bp :bprev<CR>
nnoremap <silent> <leader>bq :copen<CR>
nnoremap <silent> <leader>bl :lopen<CR>
nnoremap <silent> <leader>bx <C-^>

" Window commands
nnoremap <silent> <leader>w= <C-W>=<cr>
nnoremap <silent> <leader>w- <C-W>s<cr>
nnoremap <silent> <leader>w/ <C-W>v<cr>
nnoremap <silent> <leader>wj <C-W>j<cr>
nnoremap <silent> <leader>wh <C-W>h<cr>
nnoremap <silent> <leader>wk <C-W>k<cr>
nnoremap <silent> <leader>wl <C-W>l<cr>
nnoremap <silent> <leader>wd <C-W>c<cr>
nnoremap <silent> <leader>wL <C-W>r<cr>
nnoremap <silent> <leader>wH <C-W>R<cr>
nnoremap <silent> <leader>ww :Windows<cr>

" Git commands
nnoremap <silent> <leader>gs :Gstatus<cr>
nnoremap <silent> <leader>gc :Gcommit<cr>
nnoremap <silent> <leader>gl :Glog<cr>
nnoremap <silent> <leader>gd :Gdiff<cr>
nnoremap <silent> <leader>gb :Gblame<cr>

let g:ale_sign_column_always = 1
let g:ale_fixers = {
      \  'python': [
      \    'yapf',
      \    'isort',
      \    'add_blank_lines_for_python_control_statements',
      \    'remove_trailing_lines',
      \    'trim_whitespace',
      \  ],
      \ }
let g:ale_set_quickfix = 1
let g:ale_set_loclist = 0

let g:lightline = {
      \ 'active': {
      \   'left': [['mode', 'paste'], ['filename', 'filetype', 'modified']],
      \   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
      \ },
      \ 'component_expand': {
      \   'linter_warnings': 'LightlineLinterWarnings',
      \   'linter_errors': 'LightlineLinterErrors',
      \   'linter_ok': 'LightlineLinterOK'
      \ },
      \ 'component_type': {
      \   'readonly': 'error',
      \   'linter_warnings': 'warning',
      \   'linter_errors': 'error'
      \ },
      \ }

function! LightlineLinterWarnings() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
  let l:counts = ale#statusline#Count(bufnr(''))
  let l:all_errors = l:counts.error + l:counts.style_error
  let l:all_non_errors = l:counts.total - l:all_errors
  return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()

" Update and show lightline but only if it's visible (e.g., not in Goyo)
function! s:MaybeUpdateLightline()
  if exists('#lightline')
    call lightline#update()
  end
endfunction

nnoremap <silent> ≈ :Commands<cr>
nnoremap <silent> <leader>h :Helptags<cr>
nnoremap <silent> <leader>qq :qall<cr>

command! -bang -nargs=* Rg
      \ call fzf#vim#grep(
      \ 'rg --column --line-number --no-heading --smart-case --color=always '.shellescape(<q-args>),
      \ 1,
      \ <bang>0 ? fzf#vim#with_preview('up:60%')
      \         : fzf#vim#with_preview('right:50%:hidden', '?'),
      \ <bang>0)

augroup quickfix
  au!
  au FileType qf nnoremap <buffer> q :q<cr>
augroup END

augroup locationlist
  au!
  au FileType ll nnoremap <buffer> q :q<cr>
augroup END

augroup make
  au!
  au FileType make au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType make setl noexpandtab
  au FileType make setl nosmarttab
  au FileType make setl softtabstop=0
  au FileType make setl tabstop=4
augroup END

augroup go
  au!
  au FileType go au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType go setl noexpandtab
  au FileType go setl tabstop=4
  au FileType go setl shiftwidth=4
augroup END

augroup yaml
  au!
  au FileType yaml au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType yaml setl tabstop=4
  au FileType yaml setl shiftwidth=4
augroup END

augroup man
  au!
  au FileType man setl nolist
  au FileType man setl nonumber
  au FileType man setl tabstop=8
  au FileType man setl nomodified
  au FileType man setl nomodifiable
  au FileType man nnoremap <buffer> q :q<cr>
augroup END

augroup markdown
  au!
  au FileType markdown au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType markdown setl shiftwidth=4
  au FileType markdown setl softtabstop=4
augroup END

augroup perl
  au!
  au FileType perl au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType perl setl iskeyword+=$,%,@
augroup END

augroup puppet
  au!
  au FileType puppet au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
augroup END

augroup python
  au!
  au FileType python au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType python setl textwidth=79
  au FileType pyrex au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType pyrex setl textwidth=79
augroup END

augroup ruby
  au!
  au FileType ruby au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
augroup END

augroup shell
  au!
  au FileType sh,zsh au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
augroup END

augroup vim
  au!
  au FileType vim au BufWritePre <buffer> call RemoveTrailingWhiteSpace()
  au FileType vim setl shiftwidth=2
  au FileType vim setl softtabstop=2
  au FileType vim setl tabstop=2
augroup END

augroup help
  au!
  au FileType help setl nolist
  au FileType help setl nonumber
  au FileType help setl nomodified
  au FileType help setl nomodifiable
  au FileType help nnoremap <buffer> q :q<cr>
augroup END

augroup restoreCursorPosition
  autocmd!
  autocmd BufReadPost * call RestoreCursorPosition()
augroup END

silent execute '!mkdir -p $HOME/.vim/data/vimbackup'
silent execute '!mkdir -p $HOME/.vim/data/vimswap'
silent execute '!mkdir -p $HOME/.vim/data/vimviews'
silent execute '!mkdir -p $HOME/.vim/data/vimundo'
silent execute '!mkdir -p $HOME/.vim/data/ctrlp'
silent execute '!mkdir -p $HOME/.vim/data/tags'

" Replace word under cursor, everywhere in the file.
nnoremap <leader>r. :%s/\<C-r><C-w>\>/

" Replace visually selected characters, everywhere in the file.
vnoremap <leader>rv "hy:%s/<C-r>h/
